import matplotlib.pyplot as plt
from matplotlib.text import TextPath
from matplotlib.font_manager import FontProperties
import urllib.request
import os

# ================= CONFIGURATION =================
TEXT_TO_PRINT = "DANGER"  # Text to cut out
FILENAME = "stencil_tag.svg"
FONT_SIZE = 50
PADDING = 15              # Space around the text in mm
# =================================================

def get_stencil_font():
    """
    Checks if 'AllertaStencil-Regular.ttf' exists. 
    If not, downloads it from Google Fonts repository.
    """
    font_filename = "AllertaStencil-Regular.ttf"
    url = "https://github.com/google/fonts/raw/main/ofl/allertastencil/AllertaStencil-Regular.ttf"
    
    if not os.path.exists(font_filename):
        print(f"Downloading stencil font to {font_filename}...")
        try:
            urllib.request.urlretrieve(url, font_filename)
            print("Download complete.")
        except Exception as e:
            print(f"Error downloading font: {e}")
            return None
    return font_filename

def generate_svg():
    # 1. Load the Font
    font_path = get_stencil_font()
    if not font_path:
        print("Could not find or download a stencil font. Exiting.")
        return

    # Load font properties from the file
    fp = FontProperties(fname=font_path)

    # 2. Generate Text Path
    # This converts the string "DANGER" into mathematical curves
    text_path = TextPath((0, 0), TEXT_TO_PRINT, size=FONT_SIZE, prop=fp)

    # 3. Calculate Dimensions
    # We get the bounding box of the text to figure out how big the rectangle needs to be
    bbox = text_path.get_extents()
    
    # Calculate total width/height including padding
    rect_width = bbox.width + (PADDING * 2)
    rect_height = bbox.height + (PADDING * 2)

    # 4. Create the Rectangle Path
    # We draw a simple rectangle counter-clockwise
    # M = Move, L = Line, Z = Close
    rect_path_d = f"M 0 0 L {rect_width} 0 L {rect_width} {rect_height} L 0 {rect_height} Z"

    # 5. Create the Text Path String
    # We need to offset the text so it sits in the middle of our rectangle
    offset_x = PADDING - bbox.xmin
    offset_y = PADDING - bbox.ymin

    text_d_parts = []
    
    # Iterate through the segments of the text characters
    for vertices, code in text_path.iter_segments():
        # Offset the vertices
        x, y = vertices[-2] + offset_x, vertices[-1] + offset_y
        
        if code == text_path.MOVETO:
            text_d_parts.append(f"M {x:.2f} {y:.2f}")
        elif code == text_path.LINETO:
            text_d_parts.append(f"L {x:.2f} {y:.2f}")
        elif code == text_path.CURVE3: # Quadratic Curve
            x1, y1 = vertices[0] + offset_x, vertices[1] + offset_y
            text_d_parts.append(f"Q {x1:.2f} {y1:.2f} {x:.2f} {y:.2f}")
        elif code == text_path.CURVE4: # Cubic Curve
            x1, y1 = vertices[0] + offset_x, vertices[1] + offset_y
            x2, y2 = vertices[2] + offset_x, vertices[3] + offset_y
            text_d_parts.append(f"C {x1:.2f} {y1:.2f} {x2:.2f} {y2:.2f} {x:.2f} {y:.2f}")
        elif code == text_path.CLOSEPOLY:
            text_d_parts.append("Z")

    text_d_string = " ".join(text_d_parts)

    # 6. Construct the SVG
    # CRITICAL: We put both the Rect and Text in ONE <path> element.
    # We use fill-rule="evenodd".
    # This means: Solid Rect + Solid Text on top = The Text becomes a Hole.
    svg_content = f"""<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {rect_width} {rect_height}" width="{rect_width}mm" height="{rect_height}mm">
    <!-- Generated by Python Script for Bambu Studio -->
    <path fill="black" stroke="none" fill-rule="evenodd" d="
        {rect_path_d}
        {text_d_string}
    " />
    </svg>"""

    # 7. Save to file
    with open(FILENAME, "w") as f:
        f.write(svg_content)

    print(f"Success! '{FILENAME}' created.")
    print(f"Dimensions: {rect_width:.1f}mm x {rect_height:.1f}mm")

if __name__ == "__main__":
    generate_svg()